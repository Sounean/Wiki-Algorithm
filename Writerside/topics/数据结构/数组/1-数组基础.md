# 1.数组基础

数组属于看起来简单，实现起来却很难的，这个章节就是要额外再次去讲，升华一次，因为后面个别题除了用指针的方法做，一般题解还有就是用数组做的；
或者换句话说用指针可做的题就肯定能用数组做，数组用熟练了任何题都能解。(但是数组效率肯定比指针差的，举上面的例子是为了衬托数组的必要性和重要性)

之前不管是不是硬记数组的一些性质，下文读罢，应该做题时，面对一个数组，要立马有一个完整的数组图形的构想，该构想包括：他的内存地址、他的下标、他的值。

`数组是存放在连续内存空间上的相同类型数据的集合`,可以方便的通过下标索引的方式获取到下标对应的数据，如下图：
![数组理论01.png](数组理论01.png)
脑中构想时要记住两点红线：1.数组下标都是从0开始的，2.数组内存空间的地址是连续的

有了样子后，就应该开始对他开始操作，正是因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址：例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示
![数组理论02.png](数组理论02.png)

一维数组有概念了，再二维数组：
a[行(第一索引)][列(第二索引)]
![数组理论03.png](数组理论03.png)

那么二维数组在内存的空间地址是连续的么？不同编程语言的内存管理是不一样的，以C++为例，在C++中二维数组是连续分布的。

```C++
void test_arr() {
    int array[2][3] = {
		{0, 1, 2},
		{3, 4, 5}
    };
    cout << &array[0][0] << " " << &array[0][1] << " " << &array[0][2] << endl;
    cout << &array[1][0] << " " << &array[1][1] << " " << &array[1][2] << endl;
}

int main() {
    test_arr();
}
```

结果输出他们的地址为:
![数组理论04.png](数组理论04.png)

首先补一些内存地址的知识：&后面跟数组就可以取到数组的地址(地址默认是十六进制的形式)；以array[0][0] 和array[0][1]的地址来进行分析:
0x7ffee4065820 与 0x7ffee4065824 差了一个4(单位是字节)，这个4其实是根据数组的数据类型来的，该数组每个元素为int类型，所以数组的
每个小块的大小为int类型的大小（int类型数组占4字节大），我们可以通过结果可知两个相邻数组元素地址差4个字节，是刚好在内存地址上也是相邻的。如下图：
![数组理论05.png](数组理论05.png)

`所以可以看出在C++中二维数组在地址空间上是连续的。`